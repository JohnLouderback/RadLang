<#@ template language="C#" #>
<#@ assembly name="System.Runtime.dll" #>
<#@ output extension=".g.cs" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
/// This file is generated by `BaseASTVisitor.tt`. Please do not edit directly as it will be overwritten.

namespace RadParser.AST.Node;

public abstract class BaseASTVisitor<T> {
<#
    var path = "./AST/Node/";
    var files = Directory.GetFiles(path);
    foreach (var file in files) {
        var fileName = Path.GetFileNameWithoutExtension(file);

        // Ignore interfaces.
        if (fileName.StartsWith("I")) continue;

        // If the type is generic "Node", discard that.
        if (fileName == "Node" ||
            fileName == "NodeCollection") continue;

        var isAbstract = false;
        var isGeneric = false;

        foreach (var line in File.ReadLines(Path.Combine(path, fileName + ".cs"))) {
            // Check if the class is abstract. We ignore those.
            if (Regex.IsMatch(line, $@"abstract.*?class.*?{fileName}")) {
                isAbstract = true;
                break;
            }

            // Check if the class is generic. We ignore those.
            if (Regex.IsMatch(line, $@"class.*?{fileName}<")) {
                isGeneric = true;
                break;
            }
        }

        if (isAbstract || isGeneric) {
            continue;
        }

        WriteLine($"  public abstract T Visit({fileName} node);\n");
    }
#>
<#
    /* Explicitly include any members that couldn't included through the above heuristic. */
#>
  public abstract T Visit(Expression node);
  public abstract T Visit(Declaration node);
  public abstract T Visit(Literal node);

<#
    /* The base visitor for double dispatch. */
#>
  public T Visit(INode node) {
    return Visit((dynamic)node);
  }
}
